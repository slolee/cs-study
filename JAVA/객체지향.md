## 객체지향 프로그래밍에 대해서 설명해주실 수 있나요?

객체지향 프로그래밍은 프로그래밍에서 필요한 상태와 행위를 하나의 클래스로 캡슐화해서 객체로 만들고, 그 객체들간의 상호작용을 통해 프로그램의 로직을 만드는 프로그래밍 방식을 의미합니다.

<br>

## 객체지향 프로그래밍의 장단점에 대해서 설명해주실수 있나요?

객체지향 프로그래밍의 장점으로는 상태와 행위를 하나의 객체로 캡슐화를 하기 때문에 코드의 재사용성이 높고, 가독성과 유지보수성이 좋아집니다. 또한 클래스 단위로 모듈화해서 개발하기 때문에 업무를 분담해서 개발하기 좋다는 장점이 있어 대형 프로젝트에 적합하다고 생각합니다.

단점으로는 절차지향 프로그래밍에 비해서 속도가 상대적으로 느리고, 객체를 저장하기 위해 많은 힙 메모리 공간이 필요할 수 있습니다. 또한 객체들간의 상호작용을 고려해야하기 때문에 프로젝트의 규모가 커질수록 설계에 대해서 많은 부분을 고려해야한다는 단점이 있습니다.

<br>

## 객체지향의 특징 4가지에 대해서 설명해주세요.

객체지향의 특징에는 추상화, 다형성, 상속, 캡슐화입니다.

추상화는 구체적인 것을 감추고 전체적인 특성만 드러내는 것을 의미합니다. 이는 여러가지 의미로 해석될 수 있다고 생각하는데 첫 번째로 `복잡한 구현부분을 숨김으로써 클라이언트가 해당 코드를 보다 직관적으로 사용할 수 있도록 하는 것을 의미`합니다. 예를 들어, Stream 같은 경우 패러럴 스트림을 제공해 병렬에 대한 처리 부분을 추상화해두었고 개발자는 단순히 해당 기능을 이용하기만 하면 됩니다. 두 번째 의미로는 `공통된 곳에서 사용되는 코드를 하나로 뽑아내는 것`입니다. 이렇게 추상화함으로써 이 추상화된 코드를 여러 곳에서 이용할 수 있는 관점이 있을 것 같습니다. 이렇게 함으로써 코드의 재사용성, 가독성, 유지보수가 좋아지는 장점이 있습니다.

다형성은 `하나의 형태가 여러 형태를 가질 수 있다는 것을 의미`합니다. 예를 들어 A 클래스를 상속받는 B, C, D 클래스가 있을 때 B, C, D 클래스가 A 클래스의 메소드를 오버라이딩한 상황을 들 수 있을 것 같습니다. 특정 메소드에서 A 클래스에 대한 타입을 파라미터로 받는다면 해당 함수를 호출할 때 A, B, C, D 객체를 모두 전달할 수 있습니다. 하지만 내부에서 메소드 호출은 오버라이딩 된 내용에 따라서 다르게 동작하게 됩니다. A 클래스의 객체가 사실은 A, B, C, D 객체로 다양한 형태를 가지기 때문에 이를 다형성의 예시로 들 수 있을 것 같습니다. + 오버로딩

상속은 `하나의 클래스의 내용을 그대로 물려받는 자식 클래스를 구현할 수 있다는 것을 의미`합니다. 상속을 통해서 `코드를 재사용할 수도 있고 다형성을 구현할수도 있다는 장점`이 있습니다. 하지만 상속관계는 완벽하게 Is-a 관계일때만 사용해야 한다고 생각합니다. 왜냐하면 상속을 잘못하게되면 불필요하게 부모 클래스의 정보가 노출될 수 있기 때문입니다. 대표적인 예시로 스택 클래스는 벡터라는 클래스를 상속받고 있는데 스택에는 push, pop 메소드를 통해 데이터를 추가/삭제해야하는데 벡터를 상속받는다는 이유로 벡터에 존재하는 add, remove 와 같은 다양한 메소드가 노출되게 됩니다. 이러한 경우에는 Has-a 관계를 가지기 때문에 상속보다는 컴포지션을 사용하는 것이 좋다고 생각합니다.

캡슐화는 `특정 상태와 해당 상태에대한 동작을 하나의 클래스로 묶는 것을 의미`합니다. 캡슐화의 가장 큰 장점은 `정보은닉을 구현할 수 있다는 것`입니다. 실제로 잘 설계된 컴포넌트는 클래스 내부 데이터와 행위를 얼마나 잘 숨겼나를 지표로 판단할수도 있다고 생각합니다. 이외에도 캡슐화를 하게되면 `외부와 독립되지 때문에 결합도가 떨어지고, 그에 따라서 재사용성, 가독성, 유지보수성이 좋아진다는 장점`도 있습니다.

<br>

## 객체지향의 5원칙 SOLID 에 대해서 예시를 들어서 설명해주세요.

SOLID 원칙은 각각 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙을 의미합니다.

단일 책임 원칙은 클래스 하나가 하나의 책임만 가져야된다는 원칙으로, 다르게 말하면 하나의 클래스를 수정하기 위한 이유는 한 가지만 존재햐아한다는 것입니다. 예를 들어, 서비스 클래스에 데이터 베이스에 접근하기 위한 코드까지 포함된다면 해당 클래스는 서비스의 비즈니스 요구사항을 반영할 때도 수정도 되겠지만, 데이터 베이스에 대한 변경사항이 생길때도 수정되기 때문에 단일 책임 원칙을 위배한다고 볼 수 있을 것 같습니다.

개방 폐쇄 원칙은 확장에는 열려있고 수정에는 닫혀있도록 설계해야한다는 원칙입니다. 예를 들어, JDBC Driver 를 설명드리겠습니다. JDBC Driver 는 인터페이스로 추상화 되어있고 이를 구현하는 여러 데이터베이스들의 Driver 들이 있습니다. 새로운 데이터베이스에 대한 Driver 를 추가할 경우 해당 인터페이스를 구현하는 새로운 클래스를 만들고 기존에 사용중이던 Driver 객체를 대체해주기만 하면되지, 해당 Driver 를 사용하는 곳의 코드를 수정할 필요는 없습니다. 즉, 새로운 데이터베이스로의 확장에는 열려있고 기존에 사용중이던 코드에 대한 수정에는 닫혀있기 때문에 개방 폐쇄 원칙을 잘 지킨 예시라고 할 수 있습니다.

리스코프 치환 원칙은 상위 타입의 객체는 하위 타입의 객체로 치환해도 정상적으로 동작해야한다는 원칙입니다. 예를 들어, 특정 메소드의 인자로 부모 클래스에 대한 파라미터를 받을 때 해당 인자로 자식 클래스에 대한 객체를 전달하게 되면 자동으로 업 캐스팅되어 정상적으로 동작해야 합니다. 그러기 위해서는 해당 메소드에서는 부모 클래스에 포함되어 있는 메소드만 사용해야 하며 만약 자식 클래스에만 포함되어 있는 메소드를 사용하기 위해서는 반드시 타입체크와 같은 과정을 거쳐야 한다고 생각합니다. 그렇지 않고 특정 자식 클래스에 포함되어 있는 메소드를 사용하면 또 다른 자식 클래스에 대한 객체가 들어왔을 때 정상적으로 동작하지 않아 리스코프 치환 원칙을 위배한다고 말할 수 있습니다.

인터페이스 분리 원칙은 특정 클라이언트가 사용하는 인터페이스에는 해당 클라이언트를 위한 메소드만 가지도록 분리해야한다는 것입니다. 예를 들어, 특정 클래스에서 구현하는 인터페이스에 사용하지 않는 메소드가 포함되어 있다면, 해당 클래스는 사용하지 않더라도 해당 메소드를 오버라이딩 해야합니다. 이후 해당 인터페이스의 메소드 정의가 수정되었다고 할 때 해당 클래스는 사용하지 않는 메소드임에도 불구하고 같이 수정되어야 하는 문제가 발생하기 때문에 인터페이스 분리 원칙이 위배되었다고 생각합니다.

의존성 역전의 원칙은 자신보다 변하기 쉬운 것을 의존하지 말아야 한다는 원칙입니다. 예를 들어, 컴퓨터라는 클래스가 더 변하기 쉬운 CPU 라는 클래스를 의존하게 된다면, CPU 가 변경되었을 때 바뀔 필요가 없는 컴퓨터라는 클래스도 계속해서 변경이 일어나야 한다는 문제가 있습니다. 이러한 점에서 이 예시는 의존성 역전의 원칙을 위배했다고 할 수 있습니다.

<br>
