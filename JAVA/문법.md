## 오버로딩과 오버라이딩의 차이에 대해서 설명해주세요.

오버로딩은 반환형과 이름이 동일한 메소드를 파라미터의 개수와 타입을 다르게 여러 개 선언할 수 있는 것을 의미합니다. 대표적으로 생성자 오버로딩에 이용되는데 생성자는 반환형이 없고 메소드 이름은 고정되어 있기 때문에 오버로딩을 통해서 여러 개의 생성자를 선언할 수 있습니다.

오버라이딩은 두 가지 상황에서 사용되는데, 첫 번째는 상속관계를 가질 때 부모 클래스에 있는 메소드를 자식 클래스가 사용하고 싶은 형태로 재정의 하는 것이고, 두 번째는 추상 클래스나 인터페이스를 구현할 때 구현부없이 정의되어 있는 추상 메소드에 대해서 구현부를 추가하기 위해 재정의하는 것입니다.

<br>

## 인터페이스와 추상 클래스의 차이점에 대해서 설명해주세요.

인터페이스와 추상 클래스는 객체 생성이 아니라 확장을 목적으로 하는 것으로 메소드의 구현부가 없는 추상 메소드를 포함한다는 공통점을 가집니다.

추상 클래스는 추상 메소드와 일반 메소드를 모두 포함할 수 있고, 인스턴스 변수도 선언할 수 있지만 인터페이스는 오로지 추상 메소드로만 구성되어야 한다는 차이점이 있습니다. 하지만 자바8 부터 Default 메소드와 Static 메소드를 통해 인터페이스에도 해당 인터페이스를 구현하는 모든 클래스에서 공통으로 사용할 수 있는 구현부가 있는 메소드를 정의할 수 있습니다.

추상 클래스는 상속을 통해서 확장하고 인터페이스는 구현을 통해서 확장하게 됩니다. 따라서 추상 클래스는 단일 상속의 제한을 받지만 인터페이스는 해당 제한을 받지 않는다는 장점이 있습니다.

<br>

## 인터페이스의 장점에 대해서 설명해주세요!

가장 먼저, 구현해야할 메소드의 규격을 정의하는데 사용함으로써 협업시에 사용할 수 있다고 생각합니다. 또한 이런 규격을 통해서 정의해야할 메소드에 강제성을 부여해 잘못 정의하거나 해당 인터페이스를 구현하는 여러 클래스별로 다른 방식으로 구현하지 못하도록 제한할 수 있습니다.

인터페이스는 상속을 통해서 확장되지 않기 때문에 다중상속의 제한을 받지 않고 하나의 클래스에서 여러 인터페이스를 구현해 사용할 수 있다는 장점이 있습니다.

인터페이스를 사용하면 추상화와 다형성이 구현되기 때문에 교체가 용이하다는 장점이 있습니다. 인터페이스를 타입으로 가지는 인스턴스 변수나 파라미터에는 해당 인터페이스를 확장한 다양한 클래스의 객체가 저장될 수 있기 때문입니다.

<br>

## 인터페이스를 그러면 어떤 상황에서 사용할 수 있을까요?

인터페이스는 해당 인터페이스를 확장할 클래스들에게 구현해야되는 메소드의 규격을 강제로 정의해줘야 하는 상황에서 사용할 수 있습니다. 그리고 Thread, Runnable 인터페이스와 같이 다중상속을 우회하기 위한 목적으로 사용될 수도 있다고 생각합니다.

추가로 Serializable 인터페이스나 Cloneable 인터페이스와 같이 마킹 인터페이스로써 특정 클래스에게 어떠한 특성을 부여하기 위해서도 사용할 수 있다고 생각합니다.

<br>

## 어노테이션에 대해서 설명해주실수 있나요?

어노테이션은 인터페이스 기반의 문법으로 주석처럼 코드에 추가해 클래스, 메소드, 필드에 특별한 의미를 부여하거나 특정 기능을 주입하기 위해서 사용됩니다.

이미 JDK 에 포함되어 있는 @Overriding 와 같은 빌트인 어노테이션도 있고 개발자가 직접 추가해 AOP 구현을 목적으로 사용할수도 있습니다.

<br>

## 제네릭에 대해서 설명해주세요.

제네릭은 클래스나 메소드에서 사용될 타입을 하나로 고정하는 것이 아니라 클라이언트가 정하도록 하는 것을 말합니다. 이렇게 제네릭을 사용함으로써 여러가지 타입에 대한 클래스, 메소드를 일일히 선언하지 않아도 된다는 장점이 있습니다. 예를들어, 제네릭이 없었다면 각 클래스 타입에 해당하는 Collection 클래스를 모두 정의해줬어야 했을 것입니다.

제네릭을 사용하면 반환형도 제네릭 타입으로 지정할 수 있기 때문에 반환받은 객체를 다시 형변환 해줘야하는 번거로움도 사라진다는 장점이 있습니다.

<br>

## 만약 제네릭을 사용해 설계한 메소드에 의도하지 않은 객체가 들어오면 어떻게하나요?

제네릭 타입에 extend 나 super 키워드를 사용해 와일드카드를 구현해 해당 타입에 들어올수 있는 클래스 타입을 제한할 수 있습니다.

<br>

## 프리미티브 타입과 래퍼 클래스에 대해서 설명해주세요.

프리미티브 타입은 자바에서 기본적으로 제공해주는 데이터 타입이고, 래퍼 클래스는 이러한 프리미티브 타입에 대응되는 래퍼 클래스입니다.

`래퍼 클래스는 프리미티브 타입의 변수를 객체로 다루기 위해서 존재`합니다. 객체로 다루는 이유에는 여러가지가 있다고 생각되는데 대표적으로 제네릭에는 참조 자료형만 올 수 있기 때문에 여기에 프리미티브 타입을 사용하기 위해 래퍼 클래스를 사용할 수 있다고 생각합니다. 이외에도 Object 타입을 파라미터로 설정해놓은 메소드에 프리미티브 타입을 사용하고 싶은 경우에도 래퍼 클래스를 사용할 수 있습니다.

이외에도 래퍼 클래스에는 해당 프리미티브 타입을 다루기 위한 여러가지 메소드가 포함되어 있는데, 대표적으로 해당 타입으로 형변환을 하기 위한 parse 메소드가 있습니다.

<br>

## 래퍼 클래스를 사용할 때 주의해야할 점이 있을까요?

래퍼 클래스에 프리미티브 변수를 저장하면 자동으로 박싱 작업을 수행합니다. 이 때 래퍼 클래스에 대한 객체를 생성하게 되는데 이는 힙 영역에 메모리를 할당하는 것을 의미합니다.

만약 반복문에서 박싱, 언박싱 작업을 수행한다면 많은 메모리를 할당하게되는 문제가 있을 수 있습니다. 따라서 반복문에서 래퍼 클래스로 박싱, 언박싱을 하게 된다면 반드시 주의를 기울여야한다고 생각합니다.

<br>

## String, StringBuffer, StringBuilder 에 대해서 설명해주세요.

String, StringBuffer, StringBuilder 모두 문자열을 저장하기 위한 참조 자료형입니다.

String 객체는 Spring Pool 에 있는 불변 객체를 사용하기 때문에 문자열에 대한 수정, 추가, 삭제와 같은 작업이 불가능합니다. 더하기 연산자를 통해서 String 문자열을 append 하는 것은 실제로 문자열을 추가한 것이 아니라 또 다른 불변 객체를 가리키도록 변경한 것입니다. 따라서 문자열의 변경이 잦은 곳에서 String 객체를 사용하게 된다면 Spring Pool 에 너무 많은 불변 객체가 생길 수 있기 때문에 주의해야 합니다.

StringBuffer 와 StringBuilder 는 String 과 다르게 일반적인 객체를 통해 문자열을 저장합니다. 따라서 문자열의 변경, 추가, 삭제가 자유롭다는 장점이 있습니다.

이 중에서도 StringBuffer 는 멀티 스레드환경에서 스레드에 안전하다는 특징이 있고, StringBuilder 는 동기화 문제가 발생할 수 있습니다. 반대로 싱글 스레드환경에서는 StringBuilder 가 성능적인 이득이 있습니다.

<br>

## HashMap 과 HashTable 에 대해서 비교해서 설명해주세요.

첫 번째 차이점으로 HashTable 은 스레드에 안전하고 HashMap 은 스레드에 안전하지 않다는 점이 있습니다. 멀티 스레드에서 HashTable 은 동기화 문제가 발생하지 않지만 싱글 스레드에서는 오히려 성능이 낮습니다.

두 번째 차이점으로는 `HashTable 에는 Key 와 Value 모두에 null 값을 저장할 수 없지만 HashMap 에는 null 값을 저장`할 수 있습니다.

마지막으로 세 번째는 `HashMap 에는 보조해시가` 있어 HashTable 보다 성능이 더 좋다는 장점이 있습니다. 

결론적으로 멀티 스레드 환경에서의 안정성이 더 중요하다면 HashTable 을 사용하는 것이 좋고, 보다 더 높은 성능으로 Map 을 사용하고 싶으면 HashMap 을 사용하는 것이 좋다고 생각합니다.

<br>

## HashMap 과 TreeMap 에 대해서 비교해서 설명해주세요.

HashMap 과 TreeMap 의 가장 큰 차이점은 `데이터를 저장할 때 순서를 지키는지 여부`입니다. HashMap 은 데이터의 순서를 지키지 않고 데이터를 저장하지만 TreeMap 은 데이터의 순서를 유지하며 저장합니다. 따라서 정렬된 키 값을 기준으로 데이터를 사용해야하는 상황이라면 TreeMap 을 사용하는 것이 효과적이라고 생각합니다.

그리고 `데이터 탐색속도에서도 차이가 존재하는데 HashMap 은 데이터를 탐색하는데 필요한 속도가 O(1) 이지만, TreeMap 은 O(logN) 의 속도`가 필요합니다.

<br>

## Stack 과 Queue 를 LinkedList, Array 둘 중 어떤 것으로 구현할지에 대해서 설명해주세요.

저는 Stack 의 경우에는 배열로, Queue 의 경우에는 LinkedList 로 구현할 것 같습니다.

`배열의 단점으로 데이터의 추가, 삭제시에 데이터의 이동이 필요하다는 단점이 있는데 기본적으로 Stack 은 배열의 마지막에만 데이터를 추가하고 삭제하기 때문에 데이터 추가, 삭제에 필요한 속도가 O(1) 입니다.` 또한 데이터를 pop 했을 때 Top 을 가리키는 인덱스의 위치만 옮겨주면 되지 별도로 데이터를 삭제할 필요가 없습니다.

-> 데이터가 객체라면 null 로 초기화를 해줘야 한다.

하지만 Queue 의 경우에는 배열로 구현할 경우 데이터를 가장 앞에 넣으면서 데이터의 이동이 필요하기 때문에 O(N) 시간복잡도를 가지고 데이터의 이동도 많이 발생한다는 문제가 있습니다. 따라서 LinkedList 를 통해서 삽입, 삭제 모두 O(1) 의 시간복잡도를 가지도록 구현할 것 같습니다.

<br>

## 문자열에 대한 해시값을 만들기 위한 해시함수 구현은 어떤식으로 할 수 있을까요?

문자열의 각 아스키코드를 통해 정수로 변환하고 각 자리를 더하고, 그 값에 mod 연산을 해서 해시 값을 만든 것 같습니다. 하지만 이렇게만 하면 ABC 와 CBA 가 같은 해시 값을 가지기 때문에 `각 자리에 자리를 의미하는 소수를 곱해서 더할 것` 같습니다. 이렇게 `더해진 값에 mod 연산을 통해 해시 값을 구할 것` 같습니다.

<br>

## Value Type 과 Reference Type 의 차이점은 무엇일까요?

Value Type 은 메모리 공간에 데이터를 직접 저장하는 변수의 데이터 타입을 의미하고, Reference Type 은 메모리 공간에 주소를 저장하는 데이터 타입을 의미합니다.

이렇게 `Reference Type 을 사용하는 이유는 함수 호출시 파라미터, 반환 값 등에서 데이터의 크기가 큰 Value Type 을 반환하는 과정에서 복사하게 되면 낭비가 발생`하기 때문입니다. 따라서 `실제 데이터는 따로 저장하고 해당 주소만 복사함으로써 더 높은 효율을 가져올 수 있다`고 생각합니다.

하지만, `Reference Type 을 함수의 파라미터로 전달했을 때 함수 내부에서 해당 객체를 수정하면 원본 데이터가 수정되는 것이기 때문에 반드시 주의`해야 합니다.

<br>

## 문자열을 표현하는 방법에는 char 배열과 String 객체가 있는데 이렇게 나눠진 이유가 뭘까요?

char 배열과 String 객체 모두 문자열을 표현하기 위한 데이터 타입입니다. 하지만 char 배열은 프리미티브 타입이기 때문에 데이터만 존재하고 해당 데이터를 조작하기 위한 행위에 대해서 포함하고 있지 않습니다.

이러한 행위에 대해서 `String 클래스로 캡슐화` 함으로써 String 객체에 문자열을 저장하는 것외에도 해당 문자열을 조작하기 위한 다양한 메소드를 제공할 수 있습니다.

<br>

## Eqauls 와 == 연산자와의 차이점은 무엇인가요?

객체에 대해서 일반적인 비교연산자인 == 를 사용하게 되면 해당 객체가 메모리상에 존재하는 주소값을 비교하고, Eqauls 를 사용하게 되면 해당 객체가 동일한 객체인지 비교하게 됩니다. 따라서 두 객체가 동일한지 판단할 때는 == 연산자가 아니라 Eqauls 메소드를 사용해야 합니다. 왜냐하면 두 객체의 상태가 모두 동일하다고 하더라도 서로 다른 객체이기 때문에 저장되어 있는 메모리의 주소는 당연히 다르기 때문에 == 로 비교할 경우 False 를 반환하게 됩니다.

<br>

## Eqauls 와 HashCode 에 대해서 설명해주세요. 같이 구현해야되는 이유는 무엇일까요?

Eqauls 는 두 객체가 동일한지 비교해주는 메소드로 실제 저장되어 있는 주소값이 다르더라도 해당 객체가 가지고 있는 모든 상태가 같다면 같은 객체로 판단하기 위해 사용되는 메소드입니다. 개발자가 해당 메소드를 오버라이딩해서 두 객체의 비교 기준을 직접 정의해줄수도 있는 것으로 알고 있습니다.

HashCode 는 해당 객체에 대한 해시값을 만들어주는 메소드입니다. 즉, HashCode 메소드가 반환해주는 해시값을 이용해서 같은 객체인지 다른 객체인지 비교하는 것입니다.

`HashMap, HashSet 과 같은 Collection 은 내부적으로 두 객체를 비교하기 위해서 HashCode 를 구해 해당 해시값을 가지는 데이터가 존재하는지 먼저 확인하고 존재한다면 Eqauls 를 통해 진짜 같은 객체인지 확인하게 됩니다.`  따라서 HashCode 는 재정의하지않고 Eqauls 만 재정의하게 된다면 첫 번째 비교에서 False 가 반환되며 제대로된 동작을 하지 않게 됩니다.

정리하자면 `Eqauls 는 두 객체가 같은 내용인지 판단하기 위해 사용되고, HashCode 는 같은 객체인지 판단하기 위해 사용된다`고 말할 수 있습니다.

<br>

## Eqauls 를 구현하기 위한 과정에 대해서 간략하게 설명해주세요.

Eqauls 를 구현하기 위해서 총 5가지 조건을 만족하도록 구현해야 한다고 알고 있습니다.

첫 번째 조건은 자기자신인 this 와 비교했을 때 항상 True 를 반환해야 한다는 것이고, 두 번째 조건은 A 와 B 를 비교하는 것과 B 와 A 를 비교하는 것은 항상 같은 결과를 반환해야 한다는 것입니다.

세 번째 조건은 A 와 B 가 같고, B 와 C 가 같으면 A 와 C 가 같아야 한다는 조건으로 삼단논리를 만족해야 한다는 것을 의미합니다.

네 번째 조건은 Null 과 비교하면 항상 False 를 반환해야 한다는 것이고, 마지막 다섯 번째는 여러번 비교해도 항상 같은 결과를 반환해야한다는 조건입니다.

```
public boolean eqauls(Object obj) {
    if (obj == this)
        return true;
    if (!(obj instanceof MyObject))
        return false;
    MyObject myObject = (MyObject) obj;
    return this.name.eqauls(myObject.getName()) && this.age == myObject.getAge();
}
```

<br>

## String a = "ABC" 와 String a = new String("ABC") 의 차이점에 대해서 설명해주세요!

전자의 경우에는 Spring Pool 에 저장되어 있는 불변 객체를 단순히 참조하게 되고 후자의 경우에는 힙 메모리에 ABC 문자열을 저장하는 새로운 String 객체를 생성하게 되는 것으로 알고 있습니다.

<br>

## HashSet 에 문자열을 저장할 때 어떤 과정을 거치는지 설명해주세요.

가장 먼저 HashSet 에 저장하려는 문자열이 이미 존재하는지 비교할 것 같습니다. `비교하는 과정은 HashCode 메소드를 사용해 해시 값을 구하고 해당 해시 값을 가지는 데이터가 이미 존재하는지 확인합니다. 그리고 존재한다면 해당 객체와 Eqauls 메소드를 통해 내용까지 같은 진짜 객체인지 아니면 해시 값에서 충돌이 발생한건지 확인하는 과정`을 거치게 됩니다.

위 과정을 거쳐서 같은 데이터를 가지고 있지 않다고 판단하게 된다면 해당 문자열을 저장할 것 같습니다.

<br>

## JAVA 8 에서 추가된 것들에는 어떤 것들이 있을까요?

JAVA 8 에서 추가된 것에는 대표적으로 Lambda, Stream, Optional, CompletableFuture, Default Method 등이 있습니다.

Lambda 는 익명함수로 함수를 정의하지않고 사용하는 것을 의미합니다. 람다 표현식을 사용하며 코드를 보다 간결하게 작성할 수 있다는 장점이 있습니다. 람다를 사용한 예시로는 함수형 인터페이스의 익명클래스를 사용할 때 람다를 통해서 객체 생성 구문과 메소드 오버라이딩 구문을 생략할 수 있다는 장점이 있습니다.

Stream 은 배열이나 컬렉션에 저장된 데이터를 다양한 연산자를 통해서 하나씩 참조하며 반복적인 처리를 수행해주는 문법입니다. Stream 에서 제공해주는 연산자들은 내부 반복을 통해서 추상화해놨기 때문에 비즈니스 로직에 복잡한 반복문이 포함되지 않아도 되어 가독성이 좋아진다는 장점이 있습니다.

Optional 은 객체에 Null 이 저장되어 NullPointException 이 발생하는 것을 방지하기 위한 객체입니다. Optional 객체에 저장된 데이터를 꺼내올 때 만약 Null 이라면 NullPointException 이 발생하는 것이 아니라 개발자가 지정한 커스텀 예외를 발생시키거나 디폴트 값을 가져오도록 후처리를 할 수 있다는 장점이 있습니다.

CompletableFuture 은 자바의 비동기 처리를 도와주는 자료형으로 Future 를 확장하고 있습니다. CompletionStage 를 구현해 Callback 헬 없이 메소드 체이닝 형태로 다양한 처리를 수행할 수 있다는 장점이 있습니다.

Default Method 는 특정 인터페이스를 구현하는 여러 메소드에서 공통적으로 사용할 수 있는 메소드를 미리 정의해놓을 수 있는 것입니다. 기존에 인터페이스에는 추상 메소드만 존재해야 했지만 Default 메소드를 이용하면 함수의 구현부가 있는 메소드를 포함시킬 수 있다는 장점이 있습니다.

<br>

## 불변 클래스의 장점은 무엇일까요?

불변 클래스를 사용하면 Thread 에 안전하고 싱글톤 패턴을 적용해 가비지 컬렉터의 비용을 감소시킬 수 있다는 장점이 있습니다. 그리고 해당 객체가 애플리케이션이 실행되는 런타임 시점에 변경되지 않는다는 보장을 할 수 있습니다.