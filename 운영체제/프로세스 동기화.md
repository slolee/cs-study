## 프로세스 동기화에 대해서 설명해주세요.

여러 프로세스가 접근할 수 있는 임계영역에 동시에 접근했을 때 해당 임계구역의 데이터가 비일관성을 가질 수 있는 문제가 발생할 수 있습니다. 이러한 비일관성이 발생하지 않도록 임계구역의 데이터의 일관성을 지켜주는 것을 프로세스 동기화라고 합니다.

비일관성이란 프로세스의 접근 순서에 따라서 결과가 달라지는 것을 의미하는데 이러한 문제를 해결하기 위해서는 해당 임계구역에 접근할 수있는 프로세스의 수를 제한할 수 있습니다.

<br>

## 임계구역은 무엇인가요?

여러 프로세스나 스레드에게 공유되고 있는 자원을 임계구역이라고 합니다. 임계구역에 존재하는 리소스는 여러가지 프로세스나 스레드가 동시에 접근할 수 있기 때문에 일관성을 지켜주기 위한 동기화작업을 반드시 수행해야합니다.

`즉, 임계구역은 여러 프로세스와 스레드의 경쟁상태로부터 보호받아야 합니다.`

<br>

## 프로세스 동기화를 위한 기본조건에 대해서 설명해주세요.

임계구역에 대해서 프로세스 동기화를 지키기 위해 지켜야할 조건은 상호배제, 진행, 한정된 대기입니다.

`상호배제는 임계구역을 점유하고 있는 프로세스가 있다면 다른 프로세스들은 임계구역에 접근할 수 없다는 것`이고, `진행은 만약 임계구역을 어떤 프로세스도 점유하고 있지 않다면 점유를 원하는 프로세스들 중에 적절한 프로세스를 선택해 진행시켜야 한다는 조건`입니다. 마지막으로 `한정된 대기는 다른 프로세스들의 기아현상을 방지하기 위해 한번 임계구역을 점유한 프로세스나 스레드가 재진입하려고할 때 제한을 두어야 한다는 조건`입니다.

<br>

## Mutex 와 Semaphore 에 대해서 설명해주실 수 있나요?

Mutex 와 Semaphore 는 모두 상호배제를 구현하는 기술입니다.

Mutex 는 Lock 방식을 사용해 임계구역에 진입하는 프로세스가 스스로 해당 임계구역에 다른 프로세스가 진입하지 못하도록 제한을 걸고 임계구역에서 빠져나올 때 해당 Lock 을 해제하는 방식으로 동작합니다.

Semaphore 는 Lock 방식이 아니라 1 이상의 정수 Counter 를 두고 Wait, Notify 를 이용한 방식으로 동작합니다. 임계구역에 진입하는 프로세스는 Wait 를 호출해 임계구역에 진입을 시도합니다. 만약 진입할 수 있다면 Counter 를 1 감소하면서 임계구역에 진입하고 Counter 가 0 이하여서 진입할 수 없다면 큐에서 대기합니다.

이후 임계구역에서 빠져나올 때 Notify 를 호출해 큐에서 대기중인 프로세스를 다시 Running 상태로 만들어 임계구역에 진입하도록 합니다.

Mutex 는 임계구역에 진입할 수 있는 프로세스나 스레드의 수가 1개이지만, Semaphore 는 임계구역에 진입할 수 있는 프로세스나 스레드의 수가 1개 이상일 수 있습니다.

<br>

## Busy Waiting 에 대해서 설명해주세요.

Busy Waiting 이란 이미 임계구역을 점유하고 있는 프로세스가 있다면 해당 프로세스가 임계구역에서 빠져나왔는지 계속해서 확인하며 임계구역에 진입하고자 시도하는 것을 말합니다.

계속해서 반복문을 돌면서 확인하기 때문에 CPU 를 지속적으로 소비하게 되는 문제점이 있습니다.

따라서 진입할 수 없다면 해당 프로세스나 스레드를 Block 상태로 바꾸고, 나중에 임계구역을 점유하던 프로세스가 빠져나오면서 해당 프로세스나 스레드를 깨우는 방식을 이용하는 것이 좋습니다.

하지만 임계구역에서의 처리 주기가 짧다면 너무 많은 Context Switch 가 발생할 수 있기 때문에 오히려 Busy Waiting 이 더 좋은 성능을 낼 수도 있다고 생각합니다.

<br>

## 교착상태란 무엇인가요?

교착상태란 두 개의 프로세스가 각각 서로다른 두 개의 임계구역을 점유하고 있을 때 동시에 서로가 점유하고 있는 임계구역에 진입하고자할 때 무한히 대기하는 상태를 말합니다.

<br>

## 교착상태가 발생하는 조건에 대해서 아시나요?

교착상태가 발생하는 조건에는 상호배제, 점유대기, 순환대기, 비선점이 있습니다.

상호배제는 하나의 임계구역에는 한개의 프로세스만 진입할 수 있다는 것을 의미합니다.

`점유대기는 임계구역을 점유하고 있으면서 다른 프로세스가 이미 점유중인 임계구역에 점유하고자 대기하고 있는 프로세스가 존재해야 한다는 조건입니다.`

순환대기는 여러개의 임계구역을 점유하고 있는 서로다른 프로세스들이 있을 때 순환형태로 다른 프로세스가 가지고 있는 임계구역에 진입하고자 대기하고 있는 상태를 의미합니다.

비선점은 다른 프로세스가 특정 임계구역을 점유하고 있다면 이를 선점할 수 없다는 것을 의미합니다.

교착상태를 해결하기 위해서는 위 4개의 조건중 하나만 해결하면 됩니다.

<br>

## 은행원 알고리즘에 대해서 설명해주실 수 있나요?

은행원 알고리즘은 교착상태를 회피하기 위한 방법중 한 가지로 알고 있습니다. 즉, 특정 프로세스가 임계구역을 점유하려고 할 때 교착상태에 빠질 가능성을 판단해서 빠지지 않는다는 확신이 있을 때만 할당하는 방법입니다.

은행원 알고리즘의 핵심 개념은 `최소 한명의 고객에게 빌려줄 금액은 항상 은행이 보유하고 있어야 한다.` 는 것입니다.

// TODO : 은행원 알고리즘 세부내용..!

하지만 이러한 은행원 알고리즘을 사용하게 되면 교착상태를 회피하기 위해 임계구역을 할당하지 않기 때문에 자원의 사용량이 낮다는 단점과 시스템의 부하가 증가한다는 단점이 있습니다. 은행원 알고리즘에서의 사용자, 즉 프로세스는 계속해서 변화하고 해당 프로세스가 사용하려는 임계영역을 운영체제가 알기 어렵기 때문입니다.

즉, 오버헤드가 너무 커서 현재는 채택하지 않는 알고리즘으로 알고 있습니다.

<br>

## 식사하는 철학자 문제에 대해서 아시나요?

철학자는 생각하거나, 밥을먹거나, 배가고프거나 총 3가지 상태를 가질 수 있고, 철학자가 밥을 먹기 위해서는 양쪽에 있는 포크를 사용해야 합니다. 하지만 포크가 각자 자리에 있는 것이 아니라 두 철학자 사이마다 존재합니다.

5명의 철학자가 있을 때 5개의 포크가 존재하기 때문에 동시에 2명의 철학자만 밥을 먹을 수 있습니다.

여기서 철학자는 프로세스이고, 포크는 임계구역의 공유자원를 의미합니다. 만약 모든 철학자가 동시에 왼쪽 포크를 집게된다면 교착상태의 4가지 조건을 모두 만족해 교착상태가 발생하게 됩니다.

`식사하는 철학자 문제에서 동기화를 구현하기 위해서 철학자는 식사를 하기 위해 항상 왼쪽 포크를 먼저 들고, 만약 없다면 랜덤한 시간 후에 다시 시도하는 방식을 사용할 수 있습니다. 이렇게되면 모든 철학자가 동시에 왼쪽 포크를 집는다고 하더라도 기다리는 시간이 모두 다르기 때문에 교착상태에 빠지지 않습니다.`

또 교착상태의 발생 조건중 순환대기를 부정해 해결하는 방법도 있습니다.

`짝수번째 철학자는 왼쪽의 포크를 먼저 들고, 홀수번째 철학자는 오른쪽의 포크를 먼저 드는 것이 그 방법입니다.`

또 점유대기를 부정해 해결하는 방법도 있습니다.

`동시에 양쪽 포크를 들게 함으로써 하나의 자원을 점유하고 추가적인 자원을 점유하기위해 대기하는 상황을 없애는 것입니다.`

<br>

## 생성자, 소비자 문제에 대해서 아시나요?

생성자 소비자 문제는 생성자가 물건을 만들고, 이를 소비하는 소비자가 동시에 물건 개수를 나타내는 공유자원에 접근하면서 동기화 문제가 발생하는 문제입니다.

물건의 수를 가지는 변수에 생성자는 물건을 생성할때마다 1씩 증가시키고, 소비자는 물건을 소비할때마다 1씩 감소키기게 됩니다. 이 변수가 임계영역이기 때문에 생성자와 소비자가 동시에 접근했을 때 일관성이 깨지는 동기화 문제가 발생할 수 있습니다.

<br>

## 생성자, 소비자 문제에서 동기화 문제를 어떻게 해결할 수 있을까요?

생성자, 소비자 문제에서 동기화는 두 개의 Semaphore 를 통해서 구현할 수 있을 것 같습니다.

물건의 최대 개수를 나타내는 세마포어와, 물건의 최소 개수를 나타내는 세마포어 두 개를 생성하고 각각 0과 최대값으로 초기화합니다. 이후 생성자가 물건을 생성할 때는 먼저 최대 개수를 나타내는 세마포어에 대해서 Wait 를 하고 시작하며, 물건을 다 생성한 후에 기다리는 소비자를 깨우기 위한 목적으로 최소 개수를 나타내는 세마포어에 대해서 Notify 를 호출합니다.

소비자가 물건을 소비할 때는 먼저 최소 개수를 나타내는 세마포어에 대해서 Wait 를 하고 시작하며, 소비를 한 후에는 물건이 가득차 만들지 못하고 대기하는 생성자를 깨우기위한 목적으로 최대 개수를 나타내는 세마포어에 대해서 Notify 를 호출합니다.

혹은 간단하게 해당 변수에 대해 Mutex 를 통해 상호배제를 구현할수도 있습니다. 하지만 Mutex 를 이용하게 되면 Busy Waiting 상태에 빠져 CPU 자원이 낭비될 수 있다는 단점이 있습니다.