## 메모리 단편화에 대해서 설명해주실수 있나요?

메모리 단편화에는 내부 단편화와 외부 단편화가 있습니다. 단편화란 프로세스가 메모리에 할당되는 과정에서 특정 메모리 공간이 이용하지 못하는 공간으로 남게 되는데 이러한 것을 단편화라고 합니다.

외부 단편화는 프로세스를 메모리에 통째로 올리는 상황에서 발생합니다. 프로세스가 메모리에 올라가고 종료되는 과정을 반복하다보면 특정 프로세스와 또 다른 프로세스 사이에 다른 프로세스를 할당하기엔 적은 메모리가 존재할 수 있는데 이러한 현상을 외부 단편화라고 합니다.

내부 단편화는 메모리를 동일하게 잘라서 관리하는 페이징 상황에서 발생하는데, 메모리를 동일하게 잘르기 때문에 해당 크기보다 작은 데이터가 적재된다면 사용되지 않는 메모리가 생기게 됩니다. 이러한 현상을 내부 단편화라고 합니다.

외부 단편화와 내부 단편화 모두 사용되지 않는 메모리 영역을 만들기 때문에 메모리 낭비를 가져오지만, 외부 단편화가 내부 단편화보다 더 많은 메모리 낭비를 가져오는 것으로 알고 있습니다.

<br>

## 외부 단편화를 해결하기 위한 방법에는 어떠한 것들이 있을까요?

외부 단편화를 해결하는 방법에는 페이징을 이용하는 방법과 압축이 있습니다.

페이징은 메모리와 프로세스를 동일한 크기로 잘라 메모리에 비연속적으로 올리는 기법으로 외부 단편화가 발생하지 않습니다. 하지만 내부 단편화가 발생한다는 단점이 있습니다.

`압축은 외부 단편화가 발생해 사용되지 않는 메모리를 모아주는 과정을 의미합니다. 쉽게 설명하면 메모리에 할당되어있는 프로세스들을 압축해 사이사이에 외부 단편화에 의해 사용되지 않고 있는 메모리들을 모아주는 과정입니다. 하지만 작업 효율이 좋지 않다는 단점이 있습니다.`

<br>

## 메모리 관리기법 중에서 세그먼테이션 기법과 페이징 기법에 대해서 설명해주세요.

세그먼테이션 기법은 사용자에게 Code, Data, Stack, Heap 등의 익숙한 단위로 프로세스를 분할하는 방식입니다. 이렇게 분할된 세그먼테이션들은 각각 크기가 다르며 메모리에 비연속적으로 저장됩니다. 하지만 여전히 외부 단편화가 발생한다는 문제가 있습니다.

이렇게 세그먼테이션 기법을 사용하는 이유는 세그먼테이션 별로 다른 권한을 부여할수 있기 때문입니다.

페이징 기법은 메모리와 프로세스를 일정한 크기로 분할하는 방식을 의미합니다. 이렇게 분할된 것은 각각 프레임과 페이지로 불리게 되고, 하나의 프로세스에는 여러 개의 페이지가 나오게 됩니다. 페이지는 메모리의 각 프레임에 저장되며 당연히 비연속적으로 저장되게 됩니다. 메모리를 일정한 크기의 프레임으로 나눴기 때문에 외부 단편화가 발생하지 않지만 내부 단편화가 발생할 수 있다는 문제가 있습니다.

이렇게 페이징 기법을 사용하는 이유는 외부 단편화에 의한 메모리 낭비를 없애기 위함입니다.

`이 두개를 결합한 세그먼테이션드 페이징 기법을 통해 두 가지 장점을 모두 챙기는 방법도 있는 것으로 알고 있습니다.`

<br>

## 페이징 기법에서 페이지의 크기가 너무 크거나 너무 작다면 어떤 문제들이 발생할까요?

페이지의 크기가 너무 크다면 `내부 단편화로 낭비되는 메모리의 크기가 커지게` 됩니다. 그리고 페이지의 크기가 크기 때문에 한번 페이지 교체를 하는 입출력 시간이 길어지게 됩니다.

반면에 페이지의 크기가 너무 작다면 `페이지의 수가 많아져 페이징 테이블의 크기가 커지게` 됩니다. 그리고 특정 참조 지역성에 대한 정보만 포함하기 때문에 메모리를 효율적으로 사용할 수 있다는 장점이 있습니다.

따라서 적절한 페이지의 크기를 선택하는 것이 좋습니다.

<br>

## 메모리 Swapping 에 대해서 설명해주세요.

메모리 Swapping 이란 프로세스를 메모리가 아니라 디스크에 저장하는 것을 의미합니다. 이를 통해 다중 프로그래밍 정도를 증가시킬 수 있습니다.

CPU 는 Ready Queue 에 존재하는 프로세스가 메모리에 존재하는지 확인하고 없다면 해당 프로세스를 디스크로부터 읽어와 실행하는 방식으로 Swapping 이 발생하게 됩니다.

이때 메모리에 더 이상 자리가 없다면 메모리에 있는 프로세스 하나를 디스크로 보내야 하는데 이를 Swap-out 이라고 하고, 이렇게 빈 메모리 공간에 디스크에서 실행할 프로세스를 가져오는 작업을 Swap-in 이라고 합니다.

하지만 이러한 Swapping 은 굉장히 많은 Context Switching 비용이 필요하기 때문에 너무 빈번한 Swapping 은 오히려 시스템 성능을 악화시킬 수 있습니다.

<br>

## 가상메모리에 대해서 설명해주실수 있나요?

프로세스에게 물리적인 메모리를 직접 할당하는 것이 아니라 논리적인 가상메모리를 만들어 프로세스마다 할당하는 것을 가상메모리라고 합니다. 가상메모리를 사용하면 프로세스 전체를 메모리에 올리는 것이 아니라 일부분만 올려 프로세스를 실행할 수 있습니다. `가상메모리는 일반적으로 페이징 기법으로 구현되며 이렇게 일부 페이지만 메모리에 올리는 것을 요구 페이징 기법이라고 합니다.`

가상메모리를 사용함으로써 각각의 프로세스가 메모리 전체를 사용하는 것처럼 동작할 수 있으며, 프로세스의 일부만 메모리에 올리기 때문에 메모리의 크기보다 더 큰 프로그램도 동작시킬 수 있습니다.

`그리고 프로세스의 일부만 메모리에 올리기 때문에 더 많은 프로세스를 동시에 메모리에 올릴 수 있습니다. 이에 따라 CPU 의 사용률과 처리율이 증가한다는 장점이 있습니다.`

마지막으로 물리적인 페이지를 여러 가상 메모리에 포함시킴으로써 공유 메모리를 쉽게 구현할 수 있다는 장점이 있습니다. 공통적으로 사용되는 시스템 라이브러리나 커널에 대한 것은 물리 메모리의 한 곳에만 올리고 이를 여러 프로세스의 가상 메모리에 매핑시키는 방식으로 사용이 가능합니다.

<br>

## CPU 가 해당 페이지가 메모리에 존재하는지 디스크에 존재하는지 어떻게 판단하나요?

하드웨어의 지원을 통한 페이징 테이블을 보고 판단할 수 있습니다. `페이징 테이블에는 페이지의 번호와 현재 메모리에 있는지 디스크에 있는지 여부와 메모리에 저장되어 있다면 몇번 프레임에 존재하는지 저장되어 있습니다.`

<br>

## CPU 가 참조하려는 페이지가 메모리에 없으면 어떻게 되나요?

CPU 가 참조하려는 페이지가 메모리에 존재하지 않는다면 Page Fault Trap 이 발생하게 됩니다.

Page Fault Trap 이 발생하면 해당 프로세스는 Waiting 상태로 변경됩니다. 그리고 메모리에서 사용가능한 프레임을 찾습니다. 만약 사용가능한 프레임이 없다면 페이지 교체 알고리즘을 통해서 교체할 페이지를 찾습니다.

이렇게 교체할 페이지를 디스크에 쓰고, 사용할 페이지를 해당 프레임에 읽습니다. 이렇게 디스크 IO 작업을 맞추면 Interrupt 를 통해 해당 프로세스에게 알리고 해당 프로세스는 Ready 큐에 들어가 CPU 의 할당을 기다리게 됩니다.

`이 과정에서 페이징 테이블의 정보를 수정하는 작업도 함께 진행됩니다.`

<br>

## Page Fault Trap 이 빈번하게 발생하면 어떤 문제가 있을까요?

페이지 부재 트랩이 발생했을 때 페이지를 교체하는 과정에는 IO 작업이 2번 포함되어 있고 2번의 Context Switching 도 포함되어 있습니다. 따라서 자주 발생하게되면 전체 시스템 성능을 악화시킬 수 있을 것 같습니다.

하지만 프로그램이 실행되는 과정에서는 참조 지역성이라는 특징이 있기 때문에 Page Fault Trap 이 발생하는 수를 어느정도 완화된다고 생각합니다.

<br>

## 페이지 교체 알고리즘에 대해서 설명해주실 수 있나요? (캐시랑 똑같다!)

페이지 교체 알고리즘에는 대표적으로 FIFO, LRU 가 있습니다.

FIFO 는 먼저 메모리에 들어온 페이지를 먼저 교체 대상으로 선정하는 알고리즘입니다. FIFO 페이지 교체 알고리즘은 자주 사용되는 페이지가 교체될 수 있다는 문제가 있습니다.

페이지 교체과정이 많은 오버헤드를 가져오기 때문에 최대한 자주 사용되지 않는 페이지를 교체하는 것이 좋습니다. 가장 좋은 것은 미래에 오랫동안 사용되지 않을 페이지를 교체하는 것이 이상적이지만 이를 판단하기 어렵기 때문에 차선책으로 교체 시점까지 가장 오래 사용되지 않은 페이지를 교체하게 됩니다.

앞서 말한 페이지 교체 알고리즘이 LRU 입니다.

<br>

## 혹시 프레임 할당 알고리즘에 대해서 알고 계신가요?

프레임 할당 알고리즘은 Demand Paging 기법에서 각각의 프로세스에 몇 개의 프레임을 할당할지를 결정하는 알고리즘입니다. 할당된 프레임의 수에 따라서 페이지 부재율이 달라지게 됩니다.

하지만 할당된 프레임이 많다고 항상 페이지 부재율이 낮아지는 것은 아닙니다.

Belady 의 모순에 의하면 프레임이 많이 할당되었음에도 적게 할당된 상황보다 더 많은 페이지 부재가 발생할 수 있습니다.