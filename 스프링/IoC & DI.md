## Spring 의 3대특징에 어떤 것들이 있나요?

Spring 의 대표적인 3가지 특징으로는 IoC & DI, AOP, PSA 가 있습니다.

<br>

## IoC & DI 에 대해서 설명해주세요.

IoC 는 제어의 역전이라는 의미로 객체를 생성하고 삭제하는 관리작업을 개발자가 하는것이 아니라 프레임워크가 해준다는 것을 의미합니다. 이렇게 프레임워크에 의해서 관리되는 객체를 Bean 이라고 하며 Bean 들을 관리하기 위해 모아두는 곳을 Bean Factory 혹은 IoC 컨테이너라고 합니다.

이렇게 관리되는 Bean 을 개발자기 필요에 의해서 사용할 수 있어야하는데 특정 클래스에서 어떤 Bean 을 사용하고 싶을 때 의존성 주입 즉, DI 라는 방식을 이용하게 됩니다. 특정 클래스에서 해당 Bean 에 대한 의존성 주입을 요청하게되면 프레임워크는 IoC 컨테이너에 보관중이던 Bean 을 꺼내 해당 클래스의 객체를 생성하는 시점에 의존성을 주입해줍니다.

<br>

## IoC & DI 를 사용함으로써 얻을 수 있는 장점에는 어떤것들이 있을까요?

제가 생각하는 가장 큰 장점으로는 클래스간 결합도가 낮아지는 것이라고 생각합니다.

 A 클래스를 의존하는 B 클래스에서 직접 new 키워드를 통해 A 객체를 생성하는 것이 아니라 IoC 컨테이너에 등록된 Bean 을 의존성 주입받아 사용하기 때문입니다. 만약 A 객체에 대한 변경사항이 생기더라도 B 클래스와 같은 의존하는 클래스를 수정하지 않고 Bean 을 생성하는 코드만 수정하면 됩니다.

 <br>

 ## IoC 컨테이너에 등록된 Bean 은 어디서든 꺼내서 사용할 수 있나요?

 아니오. IoC 컨테이너에 등록된 Bean 은 Bean 끼리만 의존성 주입 받아서 사용할 수 있습니다.

 <br>

 ## 의존성 주입받는 방법에 대해서 각각 설명해주세요.

 의존성 주입을 받는 방법에는 필드 주입방식, Setter 주입방식, 생성자 주입방식으로 총 세가지가 있습니다. 필드 주입방식은 @Autowired 어노테이션을 인스턴스 필드에 붙여 의존성을 주입받는 방식이고, Setter 주입방식은 주입받으려는 객체의 Setter 를 이용해 주입받는 방식이고, 마지막으로 생성자 주입방식은 생성자를 통해 특정 Bean 을 주입받는 방식입니다.

 이 중에서 생성자 주입방식을 사용할 것을 권장하는데 해당 이유는 첫 번째로 순환참조문제를 애플리케이션 로딩시점에 식별할 수 있다는 점 때문입니다. 순환참조를 하도록 설계하는 것은 좋지 않고 필드 주입방식이나 Setter 주입방식을 이용할 경우 참조호출되는 메소드가 호출될 때 까지 별다른 예외를 식별할 수 없습니다.
 두 번째는 해당 필드에 final 키워드를 통한 불변성을 부여할 수 있다는 점입니다. 이렇게 함으로써 런타임 환경에서 해당 객체가 null 혹은 다른 값으로 변경되는 것을 사전에 방지할 수 있습니다.
 세 번째는 테스트가 쉬워진다는 점입니다. 필드 주입방식을 이용하게 되면 Mockito 와 같은 라이브러리를 활용해 의존성을 주입해줘야 하지만, 생성자 주입방식을 사용하게 되면 단순히 객체를 생성할 의존성이 필요한 객체들을 넣어주기만 하면 된다는 장점이 있습니다.

 <br>

 ## Bean Scope 에 대해서 알고 계신가요?
 
 Bean Scope 는 Bean 을 어떤 방식으로 생성할지에 대한 것으로 알고 있습니다. 별다른 설정을 하지 않으면 해당 Bean 은 싱글톤 패턴을 통해 생성되며 단 하나의 객체만 존재하게 됩니다. 이외에도 HTTP 요청당 독립적인 Bean 을 제공하거나, 하나의 세션당 독립적인 Bean 을 제공하는 등의 형태로 변환해서 사용할 수 있는 것으로 알고 있습니다.

<br>

## 싱글톤 패턴에 대해서 언급해주셨는데 간략하게 설명해주실수 있나요?

싱글톤 패턴은 애플리케이션에서 특정 객체가 단 1개만 존재하도록 구성하는 디자인 패턴입니다. 생성자를 private 으로 선언해 외부 클래스에서 새로운 객체를 선언할 수 없도록 제한한 뒤, 정적 메소드로 객체를 생성하는데 만약 이미 객체가 존재한다면 이미 존재하는 객체를 반환하도록 하고 없다면 새로운 객체를 생성해 클래스 내부에 보관하도록 싱글톤 패턴을 구성할 수 있습니다.

<br>

## 위에서 언급하신 것중에 순환참조문제에 대해서 설명해주실수 있나요?

순환참조 문제란 A 클래스가 B 클래스를 의존하고, B 클래스가 A 클래스를 의존하는 것 처럼 여러 클래스가 순환하는 형태로 의존하고 있을 때 발생하는 문제를 말합니다.

순환참조 문제는 의존성 주입방식에 따라서 약간 다르게 발생하는 것으로 알고 있습니다.

생성자 주입방식은 Bean 을 생성할 때 생성자를 통해 의존하고자 하는 Bean 을 주입받게 됩니다. 따라서 A 클래스의 Bean 을 생성하기 위해 의존하고 있는 B 클래스를 주입받으려 하고, 아직 B 클래스의 Bean 이 없기 때문에 B 클래스의 Bean 을 생성하기 위해 의존하고 있는 A 클래스를 주입받으려 하고, 아직 A 클래스의 Bean 이 없기 때문에... 하면서 순환참조문제가 발생하게 됩니다. 생성자를 이용해 의존성을 주입받기 때문에 Bean 생성과정에서 순환참조문제를 식별할수 있고, 애플리케이션 로딩 시점에서 예외가 발생하게 됩니다.

반면에 필드 주입방식과 Setter 를 이용한 주입방식은 애플리케이션이 동작하는 과정까지도 순환참조가 된 형태인지 식별할 수 없습니다. 실제로 A 클래스와 B 클래스가 순환형태로 메소드를 호출하도록 구성되어 있고, 해당 메소드가 실행되었을 때 예외가 발생합니다.

<br>

## 그렇다면 이러한 순환참조문제를 해결하기 위한 방법에는 어떠한 것이 있나요?

먼저 순환참조문제가 발생하지 않는 구조로 설계하는 것이 가장 좋은 방법이라고 생각합니다. 하지만 어쩔수 없는 상황이라면 생성자 주입방식이 아니라 필드 주입방식으로 바꾸고 메소드 순환호출이 발생하지 않도록 개발함으로써 순환참조를 하더라도 애플리케이션 로딩 시점에서 예외가 발생하지 않도록 하는 방법이 있습니다.

혹은 @Lazy 어노테이션을 사용해 순환참조 흐름에서 한 구간의 의존성 주입 시점을 뒤로 늦춰서 순환참조문제를 해결할 수 있습니다.