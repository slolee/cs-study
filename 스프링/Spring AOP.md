# Spring AOP

## Q. AOP 에 대해서 설명해주세요.

관점 지향 프로그래밍은 여러 비즈니스 로직에 포함되어 있는 공통 코드인 횡단 관심사를 분리해 별도의 모듈로 만드는 프로그래밍 방식을 말합니다.

관점 지향 프로그래밍을 통해 공통 코드를 분리하게 되면 기능 모듈화가 가능해지고 기존에 여러 비즈니스 로직에서 수정해야 할 것을 모듈에서만 수정하면 되기 때문에 유지보수 또한 편리해집니다.

<br/>

## Q. 왜 AOP 를 사용해게 되었는지 말씀해주세요.

여러가지 비즈니스 로직에 포함되어 있는 공통 코드를 횡단 관심사로 분류하고 이를 모듈화 함으로써 또 다른 비즈니스 로직에 쉽게 공통 코드를 적용할 수 있고 유지보수를 보다 쉽게 할 수 있어서 관점지향 프로그래밍을 사용하게 되었습니다.

<br/>

## Q. 조인 포인트, 포인트 컷, 위빙에 대해서 설명해주세요.

조인 포인트는 클라이언트가 호출하는 모든 비즈니스 메소드를 말합니다. 즉, AOP 에서 횡단 관심사 즉, 공통 코드가 적용될 수 있는 모든 포인트를 일컫습니다.

포인트 컷은 특정 조건으로 필터링된 조인 포인트를 의미합니다. 수 많은 조인 포인트 중에서 특정 메소드에만 공통 코드를 적용하게 되는데 이때 필터링된 특정 메소드를 포인트 컷이라고 부릅니다.

위빙은 호인트 컷으로 지정된 핵심 비즈니스 메소드가 호출될 때 공통 코드가 메소드에 삽입되는 과정을 의미합니다. 대표적으로 어플리케이션이 실행되는 동안 삽입되는 Runtime 위빙과 Byte 코드를 직접 수정해 삽입되는 위빙이 있습니다.

<br/>

## Q. Spring AOP 가 동작하는 방식에 대해서 설명해주세요.

Spring AOP 는 Proxy 방법을 사용해 AOP 를 구현합니다. AOP 를 적용하려는 메소드가 포함된 객체의 Proxy 객체를 생성해 해당 메소드가 호출될 때 Proxy 객체가 이를 가로채 내부적으로 원래 객체를 호출하는 과정을 통해 비즈니스 로직에 공통 코드를 삽입할 수 있습니다.

Spring AOP 에서 이러한 Proxy 방법을 구현하는 방법에는 JDK Dynamic Proxy 와 CGLIB 이 있습니다.

<br/>

## Q. JDK Dynamic Proxy 와 CGLIB 에 대해서 아시나요?

JDK Dynamic Proxy 는 자바에서 기본적으로 제공해주는 Proxy 클래스를 사용해 Proxy 객체를 동적으로 생성합니다. 타겟 클래스의 인터페이스를 구현하는 방식으로 Proxy 객체를 생성하기 때문에 타겟 클래스에는 반드시 추상화된 인터페이스가 존재해야 합니다.

CGLIB 는 타겟 클래스의 Byte 코드를 조작해 Proxy 객체를 생성합니다. JDK Dynamic Proxy 와의 가장 큰 차이점은 추상화되어 있는 인터페이스가 없더라도 Proxy 객체를 생성할 수 있다는 것입니다. 클래스를 상속받아 포함된 모든 메소드를 재정의하는 방식으로 Proxy 객체를 생성하기 때문에 재정의 불가능한 final 클래스나 메소드에 대해서는 Proxy 객체 생성이 불가능합니다.

<br/>

## Q. Spring AOP 를 사용할 때 주의해야될 점이 있다면 말해주세요.

Spring AOP 를 사용할 때 주의해야할 점은 내부 호출 문제가 발생할 수 있다는 것입니다. 

Spring AOP 동작을 위해 구현된 Proxy 객체는 외부의 요청에 대해서만 반응하고 비즈니스 로직이 포함된 메소드 내부에서 this 를 통해 호출하는 내부 호출의 경우에는 Proxy 객체를 호출하지 않습니다.

예를 들어 Spring AOP 로 동작하는 @Cacheable 어노테이션을 사용해 캐시를 구현하려고 할 때 해당 어노테이션이 붙은 메소드가 내부호출로 호출되는 메소드라면 캐시는 정상적으로 동작하지 않습니다.

```jsx
public class Aop {
	public String test() {
		String result = this.cache();
		return result;
	}
	@Cacheable
	public String cache() {
		System.out.println("Create Cache Data");
		return "cache data";
	}
}
```

예를 들어 위와같은 형태에서는 제대로 캐시가 동작하지 않습니다.

<br/>

## Q. Spring AOP 에서 Proxy 객체가 생성되는 과정에 대해서 이야기해주세요.

Spring AOP 는 클라이언트의 호출 시점에서 IoC 컨테이너에 의해서 AOP 를 위한 Proxy Bean 을 생성합니다. 이렇게 동적으로 생성된 Proxy Bean 은 기존 클래스의 메소드가 호출되는 시점에 공통 기능을 추가할 것이 있다면 자체적으로 판단해 추가하게 됩니다.

호출 시점에 하기 때문에 Runtime 위빙이라고 부릅니다.

<br/>

## Q. Spring AOP 를 직접 구현해보신 경험이 있나요?

네 spring-boot-starter-aop 의존성을 추가해 Spring AOP 를 구현해본 경험이 있습니다.

<br/>

## Q 어떻게 구현하셨는지 간략하게 설명해주실 수 있나요?

우선 spring-boot-starter-aop 의존성을 추가하고,

해당 어노테이션이 붙은 메소드에 공통 코드를 추가하도록 저만의 커스텀 어노테이션을 만들었습니다.

그리고 @Aspect 어노테이션을 통해 공통 코드에 대한 모듈을 작성했고 @Before, @After 와 같은 어노테이션이 붙은 메소드를 통해 공통 코드를 추가했습니다. 여기에 AspectJ 에서 지원해주는 표현식을 통해 앞서 생성한 어노테이션이 붙은 메소드들을 포인트 컷으로 지정하도록 설정했습니다.

이후 AOP 를 적용하기 위한 메소드에 커스텀 어노테이션을 붙여 AOP 를 구현했습니다.