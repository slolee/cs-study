## JPA 와 Hibernate 에 대해서 설명해주실 수 있나요?

JPA 는 Java 에서 사용되는 ORM 표준 인터페이스를 의미하고 Hibernate 는 해당 표준 인터페이스의 가장 대표적인 구현체입니다.

ORM 이란 객체와 관계형 데이터베이스의 테이블을 매핑시켜주는 도구로써 개발자가 SQL 쿼리를 직접 작성하지 않고, 데이터베이스의 테이블을 객체로써 객체지향적으로 다룰 수 있도록 해주는 도구를 의미합니다. ORM 이 없다면 객체지향적으로 설계하고 싶은 객체와 어떻게하면 데이터를 중복없이 효율적으로 저장할지에 초점을 맞춘 테이블 사이의 차이를 매꾸기 위한 SQL 쿼리를 개발자가 직접 SQL 쿼리를 통해 구현해야 합니다.

<br>

## 객체와 테이블을 매핑해준다고 했는데 어떤 문제가 있길래 이러한 작업을 해야하나요?

객체는 캡슐화, 추상화, 상속, 다형성과 같은 객체지향 특성에 맞게 설계하기를 원하고, 데이터베이스의 테이블은 데이터를 어떻게하면 중복없이 저장할지에 대해서 정규화 등을 통해 설계하기를 원합니다.

따라서 이러한 차이에서오는 패러다임의 차이가 존재하는데 예를들면 객체는 상속구조를 가질 수 있지만 데이터베이스의 테이블은 상속구조를 표현할 수 없습니다.

또한 객체에서는 또 다른 객체에 대해서 연관관계를 가지고 그 객체를 직접 이용할 수 있지만, 데이터베이스 테이블은 외래키를 가지고 별도의 쿼리를 통해 참조하는 테이블을 읽어와 이용해야 합니다.

이러한 패러다임의 차이를 채우기 위해서 개발자가 직접 SQL 쿼리를 작성해줘야 하는데, 이렇게 될 경우 반복작업이 굉장히 많이 증가하고 그에따라 유지보수가 어려워 집니다. 예를들면 테이블의 컬럼명이 수정되었을 때 해당 테이블에 대한 SQL 쿼리문을 모두 찾아 수정해야된다는 문제점이 있을 것 같습니다.

<br>

## 혹시 JPA 를 사용해보신 경험이 있다면 어떤 장점이 있어서 사용해보신건가요?

제가 JPA 를 사용한 두 가지 이유는,

첫 번째로 SQL 중심적인 개발에서 객체 중심적인 개발을 할 수 있었기 때문입니다. JPA 가 객체와 데이터베이스 테이블 사이의 매핑을 해주고 내부적으로 SQL 구문을 생성해주기 때문에 DB 와의 결합도도 낮고 직접 SQL 쿼리문을 작성하지 않아도 된다는 장점이 있습니다.

두 번째로는 Spring Data 에서 제공해주는 Repository 를 이용해 높은 생산성을 가져올 수 있다고 생각했기 때문입니다. Repository 는 한 단계 더 추상화되어 메소드 이름 규칙을 통해서 단순히 인터페이스의 추상 메소드만 추가하면 Spring Data JPA 가 해당 메소드 이름을 JPQL 로 전화해주게 됩니다. 이를 통해서 높은 생산성을 만들어 낼 수 있다고 생각했습니다.

마지막으로 JPA 의 영속성 컨텍스트가 지원하는 다양한 기능을 이용하기 위해서입니다. 영속성 컨텍스트는 1차캐시, 쓰기지연, 더티체킹, 객체비교 등 다양한 기능을 제공하는데 이를 이용해 보다 간결한 Data Access 계층의 비즈니스 로직을 작성할 수 있다고 생각합니다.

<br>

## 객체의 연관관계란 무엇인가요?

특정 객체가 인스턴스 필드로 또 다른 객체를 가지고 있는 것을 의미합니다. 즉, 다시말해 하나의 객체가 또 다른 객체가 참조하고 있는 관계를 연관관계라고 합니다.

객체의 연관관계에는 단방향 연관관계와 양방향 연관관계가 있습니다.

<br>

## JPA 에서 이러한 연관관계를 어떻게 테이블에 매핑시키나요?

객체는 참조를 통해 객체의 연관관계를 찾는 반면에 데이터베이스의 테이블은 외래키를 이용한 Join 쿼리로 연관된 테이블을 조회합니다.

이러한 패러다임 차이를 극복하기 위해 JPA 는 @ManyToOne, @OneToMany, @OneToOne, @ManyToMany 와 같은 어노테이션을 이용해 Entity 간의 연관관계를 지정한다. 그러면 JPA 가 해당 객체에 대한 SQL 쿼리를 작성할 때 해당 어노테이션을 통해 연관관계를 가지는 객체를 가져오기 위한 SQL 쿼리도 함께 작성하고, 이 결과를 조합하는 과정까지 직접 처리한다.

단, 연관관계가 너무 많아지게 되면 N+1 문제로 인한 성능 저하가 발생할 수 있기 때문에 지연로딩과 Fatch Join 을 적절히 이용해야 하는 것으로 알고 있습니다.

양방향 연관관계일 경우 객체의 경우 양쪽 객체에 서로에 대한 참조가 존재하지만 테이블은 여전히 한쪽 테이블에만 외래키가 존재하게 됩니다. 따라서 해당 연관관계의 주인을 mappedBy 라는 속성을 통해서 지정해줘야 합니다. 일반적으로 외래키를 가지는 테이블에 대한 Entity 를 연관관계의 주인으로 지정하는 것이 좋다고 생각합니다.

왜냐하면 연관관계의 주인인 Entity 객체를 수정해야만 데이터베이스에 반영되는데, 만약 연관관계의 주인이 외래키를 가지지 않는 테이블이라고 했을때 해당 Entity 객체를 수정했을 때 실제 해당 테이블외에도 연관관계를 위한 외래키를 가지는 테이블까지도 수정될 수 있기 때문에 복잡해진다고 생각하기 때문입니다.

<br>

## 지연로딩에 대해서 설명해주실 수 있나요?

지연로딩이란 어떤 Entity 객체가 연관관계를 가지고 있는 상황에서 해당 객체에 대한 SQL 쿼리를 사용할 때 연관관계를 가지는 모든 객체에 대한 SQL 쿼리를 바로 날리는 것이 아니라 Proxy 객체로 대체해놓고 해당 객체가 실제로 사용되는 시점에 SQL 쿼리를 날리는 것을 지연로딩이라고 합니다.

지연로딩을 사용하지 않았을 경우 Entity 객체의 연관관계가 많아지면 많아질수록 발생되는 SQL 쿼리수는 증가하고 그에 따라 성능 저하가 발생할 수 있습니다.

<br>

## 양방향 매핑에서 주의해야할 점이 있나요?

양방향 매핑이란 사실은 단방향 매핑이 두 개가 존재하는 것입니다. 따라서 양방향 매핑시에는 이 두 개의 단방향 매핑 중에서 연관관계의 주인을 mappedBy 속성을 통해서 지정해주게 됩니다.

`이때 연관관계의 주인이 아닌 Entity 객체를 수정해도 외래키에 반영이 되지 않습니다. 따라서 반드시 연관관계의 주인인 Entity 객체를 수정해줘야 합니다.`

<br>

## EntityManager 에 대해서 설명해주실 수 있나요?

EntityManager 는 Entity 를 관리하기 위한 목적으로 사용되는 클래스로 내부에 영속성 컨텍스트를 두어 Entity 들을 관리하게 됩니다.

EntityManager 에는 persist, save, update, remove 와 같은 Entity 를 관리하기 위한 메소드들이 제공되어 개발자가 직접 SQL 쿼리문을 작성하지 않아도 commit, flush 되는 타이밍에 자동으로 SQL 쿼리문을 동적으로 작성해 데이터베이스에 전달하는 역할을 수행합니다.

<br>

## EntityManager 와 Repository 에 대해서 비교해서 설명해주실수 있나요?

EntityManager 는 JPA 에서 제공하는 Entity 를 관리하기 위한 클래스이고, Repository 는 Spring Data 에서 제공하는 한 단계 더 추상화된 기술을 의미합니다.

EntityManager 에서 개발자가 직접 persist, update, save, remove 와 같은 메소드 호출을 통해 Entity 를 제어했지만 Repository 에서는 인터페이스에 메소드만 추가하게되면 메소드 이름의 규측을 통해 자동으로 JPQL 쿼리를 동적으로 생성해주고 이를 사용해 데이터베이스에 쿼리를 전송하게 됩니다.

이러한 Repository 는 애플리케이션 로딩시점에서 Spring Data JPA 에 의해서 구현체가 생성되어 IoC 컨테이너에 Bean 으로 등록되는 것으로 알고 있습니다. 개발자는 Repository 에 포함되어 있는 각 메소드들의 세부 구현체를 구현할 필요 없이 단순이 해당 Bean 을 의존성 주입받아서 사용하기만 하면 됩니다.

이를 통해 EntityManager 를 사용했을 때 반복되던 작업을 보다 추상화된 기술로 간단하게 처리할 수 있고, 자연스럽게 생산성이 높아진다고 생각합니다.

<br>

## 영속성 컨텍스트가 무엇인가요?

영속성 컨텍스트란 객체와 데이터베이스 테이블 사이에 존재하며 1차캐시, 더티체킹, 쓰기지연, 객체비교와 같은 기능을 제공해주는 것을 의미합니다. 개발자가 데이터베이스로부터 객체를 읽어오면 이를 Entity 라고 칭하는데 이러한 Entity 객체를 영속성 컨텍스트에 보관하며 위에서 설명한 기능들을 제공합니다.

<br>

## 영속성 컨텍스트가 지원하는 것들에 대해서 설명해주실 수 있나요?

영속성 컨텍스트는 객체와 데이터베이스 테이블 사이에 존재하며 Entity 의 캐시, 동일성 보장, 더티체킹, 쓰기지연과 같은 기능을 제공합니다.

캐시란 영속성 컨텍스트에 캐시정보를 두어 개발자가 데이터베이스에서 Entity 를 읽어가면 해당 캐시에 정보를 보관해두는 것을 의미합니다. 이렇게 함으로써 반복된 읽기 작업에서 실제로 데이터베이스에 접근하지 않아도 되도록 해 성능을 높이고, 더티체킹과 동일성 보장과 같은 기능을 구현하는데 사용됩ㄴ디ㅏ.

동일성 보장이란 기존에 ORM 을 사용하지 않고 동일한 Entity 를 두 번 데이터베이스에서 읽어오게되면 각각 다른 객체에 데이터가 저장되기 때문에 비교해도 다른 객체라는 결과가 나오는데, 이러한 부분을 같은 객체로 판단할 수 있도록 해주는 기능을 의미합ㄴ디ㅏ.

더티체킹이란 해당 트랜잭션이 commit 되거나 flush 될 때 Update 쿼리를 자동으로 생성하기 위해 영속성 컨텍스트에 존재하는 1차캐시의 값과 Entity 객체의 값을 비교해 변경된 사항이 있는지 확인하는 기능을 말합니다. 이를 통해서 개발자는 update 라는 별도의 메소드 호출없이도 영속성 객체의 데이터 수정만으로 Update 쿼리를 사용할 수 있습니다.

마지막으로 쓰기지연은 Entity 객체를 여러번 수정하더라도 수정할 때마다 Update 쿼리를 생성하는 것이 아니라 트랜잭션이 commit 되거나 flush 될 때 한번에 동적으로 Update 쿼리를 작성하는 것을 말합니다.

<br>

## N + 1 문제에 대해서 설명해주실 수 있나요?

N + 1 문제는 특정 Entity 객체가 연관관계를 가지고 있을 때 해당 Entity 객체에 대한 SQL 쿼리를 데이터베이스에게 보내게되면 JPA 가 해당 연관관계에 대한 모든 SQL 쿼리를 작성해 날릴 경우 발생하는 문제를 말합니다.

최초 객체를 가져오기 위한 1 번의 쿼리와 연관관계를 가지는 객체들을 읽어오기위한 쿼리 N 번을 합쳐 N + 1 문제라고 부르는 것으로 알고 있습니다. 이러한 N + 1 문제는 요청 수가 증가함에 따라 혹은 연관관계가 많아짐에 따라 기하급수적으로 데이터베이스에 전달하는 SQL 쿼리의 수가 증가하고 성능에 큰 문제를 발생시킬 수 있습니다.

<br>

## N + 1 문제를 해결하기 위한 방법에는 어떤것이 있나요?

N + 1 문제를 해결하기 위해서는 가장먼저 특정 Entity 객체에 대한 SQL 쿼리를 날릴때 연관관계에 대한 SQL 쿼리를 바로 날리지 않도록 지연로딩으로 전환해야 합니다.

그리고 해당 연관관계의 정보가 필요하다면 JPQL 의 Fetch Join 을 이용해 N + 1 번의 쿼리가 아니라 Join 을 이용한 한방쿼리로 데이터베이스에 날리도록 함으로써 N + 1 문제를 해결할 수 있습니다.

<br>

## JPA 를 이용해서 복잡한 쿼리를 작성해야할 때는 어떻게하나요?

JPA 를 이용해 복잡한 쿼리를 작성하기 위해서는 JPQL 쿼리문을 직접 작성하는 방법을 사용할 수 있습니다. JPQL 은 여러 데이터베이스의 SQL 문법이 추상화되어 있어 종속성을 가지지 않는 쿼리를 작성할 수 있다는 장점이 있습니다.

이외에도 QueryDSL 와 같은 함수형 라이브러리를 사용해 직관적이면서도 복잡한 쿼리를 작성할 수 있습니다. QueryDSL 은 함수형 프로그래밍방식으로 SQL 쿼리문을 생성하기 때문에 애플리케이션 로딩 시점에 쿼리의 에러를 식별할 수 있습니다.

하지만 JPA 로 복잡한 쿼리를 구현하게 되면 내부적으로 자동으로 생성해주는 SQL 중에 불필요한 것들이 많이 추가될 수 있습니다. 이러한 것들은 SQL 쿼리의 성능을 저하시키기 때문에 이럴 경우 개발자가 직접 세부적인 SQL 쿼리를 작성하는 MyBatis 와 같은 SQL Mapper 를 이용하는 것도 하나의 방법일 것 같습니다.
