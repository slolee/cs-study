## 데이터베이스 인덱스에 대해서 설명해주실 수 있나요?

데이터베이스에서 인덱스란 책에서 목차와 같은 역할로 데이터 조회 속도를 높이기 위해 사용됩니다. 특정 컬럼으로 정렬된 인덱스 테이블을 통해 특정 데이터를 빠르게 탐색할 수 있습니다.

`특정 데이터를 찾기 위해 해당 테이블을 모두 탐색하면 속도가 느려지기 때문에 정렬된 특정 컬럼과 해당 로우의 위치를 함께 저장해 빠른 속도로 해당 데이터를 찾습니다.`

인덱스를 사용하면 조회 속도는 빨라지지만 삽입, 삭제, 수정에 대한 쿼리 속도는 저하되게 됩니다. 왜냐하면 이렇게 테이블의 데이터에 변경이 발생할 경우 그에 맞게 인덱스 테이블도 수정해줘야하기 때문입니다. 심지어 삭제의 경우 해당 인덱스 테이블에서 해당 데이터를 지우는 것이 아니라 비활성화 시키는 것이기 때문에 반복되게 된다면 인덱스 테이블이 너무 커져 저장공간 낭비가 발생할 수 있습니다.

<br>

## 이러한 인덱스는 어떤 자료구조로 만들 수 있을까요?

인덱스를 만드는데 사용되는 자료구조에는 해시테이블과 B Tree 가 있습니다.

해시테이블이 탐색속도가 O(1) 로 더 빠르지만 등호 연산자만 사용이 가능하고 부등호 연산이 불가능 하다는 문제가 있기 때문에 일반적으로 B Tree 자료구조를 사용해 인덱스를 구현하는 것으로 알고 있습니다.

<br>

## 인덱스의 종류에는 클러스터 인덱스와 넌클러스터 인덱스가 있는데 각각 설명해주실 수 있나요?

클러스터 인덱스는 물리적으로 테이블을 정렬하는 인덱스 방식입니다. 물리적으로 실제 데이터를 정렬하기 때문에 테이블당 1개밖에 존재하지 못하며 일반적으로 Primary Key 로 설정한 컬럼을 통해 클러스터 인덱스를 사용하는 것으로 알고 있습니다.

넌클러스터 인덱스는 물리적으로 테이블을 정렬하는 것이 아니라 논리적인 인덱스 테이블을 생성해 정렬하는 방식입니다. 따라서 클러스터 인덱스와는 다르게 1개 이상의 인덱스를 생성할 수 있습니다.

<br>

## 클러스터 인덱스와 넌클러스터 인덱스의 구현방식에 대해서 아시나요?

클러스터 인덱스는 물리적인 테이블 자체가 정렬되기 때문에 B Tree 에서 리프노드에 데이터를 보관하지 않습니다.

반면에 넌클러스터 인덱스는 리프노드에 인덱스로 설정된 컬럼에 대한 정보와 해당 데이터가 물리 테이블 어느 Offset 에 위치하는지에 대한 정보도 함께 포함됩니다. 논리적으로 정렬되는 것이기 때문에 해당 Offset 을 통해 물리 테이블에 있는 데이터를 찾아가기 위함입니다.

<br>

## 그럼 인덱스를 어느 상황에서 사용하는 것이 좋을까요?

인덱스는 기본적으로 테이블에 조회 쿼리가 삽입, 삭제, 수정 쿼리보다 많을 때 사용하는 것이 좋습니다. 왜냐하면 인덱스를 사용하게 되면 삽입, 삭제, 수정에 대한 쿼리 속도가 저하되고 조회 속도는 빨라지기 때문입니다. 조회 쿼리의 비중이 더 클 수록 인덱스로 얻을 수 있는 성능향상이 높다고 생각합니다.

두 번째로 Join, Where, Order By 연산자가 많이 사용되는 테이블에 사용하면 좋다고 생각합니다. 왜냐하면 위와같은 연산자를 사용하기 위해서는 테이블 전체를 조회해야하기 때문입니다.

<br>

## 그럼 인덱스를 어떤 컬럼에 설정하는 것이 좋을까요?

인덱스를 설정하기 좋은 컬럼은 중복된 데이터가 적고 Where, Order By 절에서 자주 사용되는 컬럼이 좋다고 생각합니다.